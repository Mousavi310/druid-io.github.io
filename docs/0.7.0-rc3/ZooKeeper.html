<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Apache Druid">
<meta name="keywords" content="druid,kafka,database,analytics,streaming,real-time,real time,apache,open source">
<meta name="author" content="Apache Software Foundation">

<title>Druid | </title>

<link rel="alternate" type="application/atom+xml" href="/feed">
<link rel="shortcut icon" href="/img/favicon.png">

<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">

<link href='//fonts.googleapis.com/css?family=Open+Sans+Condensed:300,700,300italic|Open+Sans:300italic,400italic,600italic,400,300,600,700' rel='stylesheet' type='text/css'>

<link rel="stylesheet" href="/css/bootstrap-pure.css?v=1.0">
<link rel="stylesheet" href="/css/main.css?v=1.0">
<link rel="stylesheet" href="/css/header.css?v=1.0">
<link rel="stylesheet" href="/css/footer.css?v=1.0">
<link rel="stylesheet" href="/css/syntax.css?v=1.0">
<link rel="stylesheet" href="/css/docs.css?v=1.0">

<script>
  (function() {
    var cx = '000162378814775985090:molvbm0vggm';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>


  </head>

  <body>
    <!-- Start page_header include -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>

<div class="top-navigator">
  <div class="container">
    <div class="left-cont">
      <a class="logo" href="/"><span class="druid-logo"></span></a>
    </div>
    <div class="right-cont">
      <ul class="links">
        <li class=""><a href="/technology">Technology</a></li>
        <li class=""><a href="/use-cases">Use Cases</a></li>
        <li class=""><a href="/druid-powered">Powered By</a></li>
        <li class=""><a href="/docs/latest/design/">Docs</a></li>
        <li class=""><a href="https://druid.apache.org/community/">Community</a></li>
        <li class=" button-link"><a href="/downloads.html">Download</a></li>
      </ul>
    </div>
  </div>
  <div class="action-button menu-icon">
    <span class="fa fa-bars"></span> MENU
  </div>
  <div class="action-button menu-icon-close">
    <span class="fa fa-times"></span> MENU
  </div>
</div>

<script type="text/javascript">
  var $menu = $('.right-cont');
  var $menuIcon = $('.menu-icon');
  var $menuIconClose = $('.menu-icon-close');

  function showMenu() {
    $menu.fadeIn(100);
    $menuIcon.fadeOut(100);
    $menuIconClose.fadeIn(100);
  }

  $menuIcon.click(showMenu);

  function hideMenu() {
    $menu.fadeOut(100);
    $menuIconClose.fadeOut(100);
    $menuIcon.fadeIn(100);
  }

  $menuIconClose.click(hideMenu);

  $(window).resize(function() {
    if ($(window).width() >= 840) {
      $menu.fadeIn(100);
      $menuIcon.fadeOut(100);
      $menuIconClose.fadeOut(100);
    }
    else {
      $menu.fadeOut(100);
      $menuIcon.fadeIn(100);
      $menuIconClose.fadeOut(100);
    }
  });
</script>

<!-- Stop page_header include -->


    <div class="container doc-container">
      
      

      
      <p> Looking for the <a href="/docs/0.14.0-incubating/">latest stable documentation</a>?</p>
      

      <div class="row">
        <div class="col-md-9 doc-content">
          <p>
            <a class="btn btn-default btn-xs visible-xs-inline-block visible-sm-inline-block" href="#toc">Table of Contents</a>
          </p>
          <h1 id="zookeeper">ZooKeeper</h1>

<p>Druid uses <a href="http://zookeeper.apache.org/">ZooKeeper</a> (ZK) for management of current cluster state. The operations that happen over ZK are</p>

<ol>
<li> <a href="Coordinator.html">Coordinator</a> leader election</li>
<li> Segment &quot;publishing&quot; protocol from <a href="Historical.html">Historical</a> and <a href="Realtime.html">Realtime</a></li>
<li> Segment load/drop protocol between <a href="Coordinator.html">Coordinator</a> and <a href="Historical.html">Historical</a></li>
<li> <a href="Indexing-Service.html">Overlord</a> leader election</li>
<li> <a href="Indexing-Service.html">Indexing Service</a> task management</li>
</ol>

<h3 id="property-configuration">Property Configuration</h3>

<p>ZooKeeper paths are set via the <code>runtime.properties</code> configuration file. Druid will automatically create paths that do not exist, so typos in config files is a very easy way to become split-brained.</p>

<table><thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead><tbody>
<tr>
<td><code>druid.zk.service.host</code></td>
<td>The ZooKeeper hosts to connect to. This is a REQUIRED property and therefore a host address must be supplied.</td>
<td>none</td>
</tr>
<tr>
<td><code>druid.zk.service.sessionTimeoutMs</code></td>
<td>ZooKeeper session timeout, in milliseconds.</td>
<td><code>30000</code></td>
</tr>
<tr>
<td><code>druid.curator.compress</code></td>
<td>Boolean flag for whether or not created Znodes should be compressed.</td>
<td><code>false</code></td>
</tr>
</tbody></table>

<h3 id="path-configuration">Path Configuration</h3>

<p>Druid interacts with ZK through a set of standard path configurations. We recommend just setting the base ZK path, but all ZK paths that Druid uses can be overwritten to absolute paths.</p>

<table><thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead><tbody>
<tr>
<td><code>druid.zk.paths.base</code></td>
<td>Base Zookeeper path.</td>
<td><code>/druid</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.propertiesPath</code></td>
<td>Zookeeper properties path.</td>
<td><code>${druid.zk.paths.base}/properties</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.announcementsPath</code></td>
<td>Druid node announcement path.</td>
<td><code>${druid.zk.paths.base}/announcements</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.liveSegmentsPath</code></td>
<td>Current path for where Druid nodes announce their segments.</td>
<td><code>${druid.zk.paths.base}/segments</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.loadQueuePath</code></td>
<td>Entries here cause historical nodes to load and drop segments.</td>
<td><code>${druid.zk.paths.base}/loadQueue</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.coordinatorPath</code></td>
<td>Used by the coordinator for leader election.</td>
<td><code>${druid.zk.paths.base}/coordinator</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.servedSegmentsPath</code></td>
<td>@Deprecated. Legacy path for where Druid nodes announce their segments.</td>
<td><code>${druid.zk.paths.base}/servedSegments</code></td>
</tr>
</tbody></table>

<p>The indexing service also uses its own set of paths. These configs can be included in the common configuration.</p>

<table><thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead><tbody>
<tr>
<td><code>druid.zk.paths.indexer.base</code></td>
<td>Base zookeeper path for</td>
<td><code>${druid.zk.paths.base}/indexer</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.indexer.announcementsPath</code></td>
<td>Middle managers announce themselves here.</td>
<td><code>${druid.zk.paths.indexer.base}/announcements</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.indexer.tasksPath</code></td>
<td>Used to assign tasks to middle managers.</td>
<td><code>${druid.zk.paths.indexer.base}/tasks</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.indexer.statusPath</code></td>
<td>Parent path for announcement of task statuses.</td>
<td><code>${druid.zk.paths.indexer.base}/status</code></td>
</tr>
<tr>
<td><code>druid.zk.paths.indexer.leaderLatchPath</code></td>
<td>Used for Overlord leader election.</td>
<td><code>${druid.zk.paths.indexer.base}/leaderLatchPath</code></td>
</tr>
</tbody></table>

<p>If <code>druid.zk.paths.base</code> and <code>druid.zk.paths.indexer.base</code> are both set, and none of the other <code>druid.zk.paths.*</code> or <code>druid.zk.paths.indexer.*</code> values are set, then the other properties will be evaluated relative to their respective <code>base</code>.
For example, if <code>druid.zk.paths.base</code> is set to <code>/druid1</code> and <code>druid.zk.paths.indexer.base</code> is set to <code>/druid2</code> then <code>druid.zk.paths.announcementsPath</code> will default to <code>/druid1/announcements</code> while <code>druid.zk.paths.indexer.announcementsPath</code> will default to <code>/druid2/announcements</code>.</p>

<p>The following path is used service discovery and are <strong>not</strong> affected by <code>druid.zk.paths.base</code> and <strong>must</strong> be specified separately.</p>

<table><thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead><tbody>
<tr>
<td><code>druid.discovery.curator.path</code></td>
<td>Services announce themselves under this ZooKeeper path.</td>
<td><code>/druid/discovery</code></td>
</tr>
</tbody></table>

<h3 id="coordinator-leader-election">Coordinator Leader Election</h3>

<p>We use the Curator LeadershipLatch recipe to do leader election at path</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>${druid.zk.paths.coordinatorPath}/_COORDINATOR
</code></pre></div>
<h3 id="segment-publishing-protocol-from-historical-and-realtime">Segment &quot;publishing&quot; protocol from Historical and Realtime</h3>

<p>The <code>announcementsPath</code> and <code>servedSegmentsPath</code> are used for this.</p>

<p>All <a href="Historical.html">Historical</a> and <a href="Realtime.html">Realtime</a> nodes publish themselves on the <code>announcementsPath</code>, specifically, they will create an ephemeral znode at</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>${druid.zk.paths.announcementsPath}/${druid.host}
</code></pre></div>
<p>Which signifies that they exist. They will also subsequently create a permanent znode at</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>${druid.zk.paths.servedSegmentsPath}/${druid.host}
</code></pre></div>
<p>And as they load up segments, they will attach ephemeral znodes that look like</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>${druid.zk.paths.servedSegmentsPath}/${druid.host}/_segment_identifier_
</code></pre></div>
<p>Nodes like the <a href="Coordinator.html">Coordinator</a> and <a href="Broker.html">Broker</a> can then watch these paths to see which nodes are currently serving which segments.</p>

<h3 id="segment-load-drop-protocol-between-coordinator-and-historical">Segment load/drop protocol between Coordinator and Historical</h3>

<p>The <code>loadQueuePath</code> is used for this.</p>

<p>When the <a href="Coordinator.html">Coordinator</a> decides that a <a href="Historical.html">Historical</a> node should load or drop a segment, it writes an ephemeral znode to</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>${druid.zk.paths.loadQueuePath}/_host_of_historical_node/_segment_identifier
</code></pre></div>
<p>This node will contain a payload that indicates to the historical node what it should do with the given segment. When the historical node is done with the work, it will delete the znode in order to signify to the Coordinator that it is complete.</p>

        </div>
        <div class="col-md-3">
          <div class="searchbox">
            <gcse:searchbox-only></gcse:searchbox-only>
          </div>
          <div id="toc" class="nav toc hidden-print">
          </div>
        </div>
      </div>
    </div>

    <!-- Start page_footer include -->
<footer class="druid-footer">
<div class="container">
  <div class="text-center">
    <p>
    <a href="/technology">Technology</a>&ensp;·&ensp;
    <a href="/use-cases">Use Cases</a>&ensp;·&ensp;
    <a href="/druid-powered">Powered by Druid</a>&ensp;·&ensp;
    <a href="/docs/latest">Docs</a>&ensp;·&ensp;
    <a href="https://druid.apache.org/community/">Community</a>&ensp;·&ensp;
    <a href="/downloads.html">Download</a>&ensp;·&ensp;
    <a href="/faq">FAQ</a>
    </p>
  </div>
  <div class="text-center">
    <a title="Join the user group" href="https://groups.google.com/forum/#!forum/druid-user" target="_blank"><span class="fa fa-comments"></span></a>&ensp;·&ensp;
    <a title="Follow Druid" href="https://twitter.com/druidio" target="_blank"><span class="fab fa-twitter"></span></a>&ensp;·&ensp;
    <a title="Download via Apache" href="https://www.apache.org/dyn/closer.cgi?path=/incubator/druid/0.14.0-incubating/apache-druid-0.14.0-incubating-bin.tar.gz" target="_blank"><span class="fas fa-feather"></span></a>&ensp;·&ensp;
    <a title="GitHub" href="https://github.com/apache/incubator-druid" target="_blank"><span class="fab fa-github"></span></a>
  </div>
  <div class="text-center license">
    Except where otherwise noted, licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>
  </div>
</div>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40280432-1', 'auto');
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');

</script>
<script>
  function trackDownload(type, url) {
    ga('send', 'event', 'download', type, url);
  }
</script>
<script src="//code.jquery.com/jquery.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script src="/assets/js/druid.js"></script>
<!-- stop page_footer include -->


    <script>
    $(function() {
      $(".toc").load("/docs/0.7.0-rc3/toc.html");

      // There is no way to tell when .gsc-input will be async loaded into the page so just try to set a placeholder until it works
      var tries = 0;
      var timer = setInterval(function() {
        tries++;
        if (tries > 300) clearInterval(timer);
        var searchInput = $('input.gsc-input');
        if (searchInput.length) {
          searchInput.attr('placeholder', 'Search');
          clearInterval(timer);
        }
      }, 100);
    });
    </script>
  </body>
</html>
