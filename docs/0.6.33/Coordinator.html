<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Apache Druid">
<meta name="keywords" content="druid,kafka,database,analytics,streaming,real-time,real time,apache,open source">
<meta name="author" content="Apache Software Foundation">

<title>Druid | </title>

<link rel="alternate" type="application/atom+xml" href="/feed">
<link rel="shortcut icon" href="/img/favicon.png">

<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">

<link href='//fonts.googleapis.com/css?family=Open+Sans+Condensed:300,700,300italic|Open+Sans:300italic,400italic,600italic,400,300,600,700' rel='stylesheet' type='text/css'>

<link rel="stylesheet" href="/css/bootstrap-pure.css?v=1.0">
<link rel="stylesheet" href="/css/main.css?v=1.0">
<link rel="stylesheet" href="/css/header.css?v=1.0">
<link rel="stylesheet" href="/css/footer.css?v=1.0">
<link rel="stylesheet" href="/css/syntax.css?v=1.0">
<link rel="stylesheet" href="/css/docs.css?v=1.0">

<script>
  (function() {
    var cx = '000162378814775985090:molvbm0vggm';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>


  </head>

  <body>
    <!-- Start page_header include -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>

<div class="top-navigator">
  <div class="container">
    <div class="left-cont">
      <a class="logo" href="/"><span class="druid-logo"></span></a>
    </div>
    <div class="right-cont">
      <ul class="links">
        <li class=""><a href="/technology">Technology</a></li>
        <li class=""><a href="/use-cases">Use Cases</a></li>
        <li class=""><a href="/druid-powered">Powered By</a></li>
        <li class=""><a href="/docs/latest/design/">Docs</a></li>
        <li class=""><a href="/community/">Community</a></li>
        <li class=" button-link"><a href="/downloads.html">Download</a></li>
      </ul>
    </div>
  </div>
  <div class="action-button menu-icon">
    <span class="fa fa-bars"></span> MENU
  </div>
  <div class="action-button menu-icon-close">
    <span class="fa fa-times"></span> MENU
  </div>
</div>

<script type="text/javascript">
  var $menu = $('.right-cont');
  var $menuIcon = $('.menu-icon');
  var $menuIconClose = $('.menu-icon-close');

  function showMenu() {
    $menu.fadeIn(100);
    $menuIcon.fadeOut(100);
    $menuIconClose.fadeIn(100);
  }

  $menuIcon.click(showMenu);

  function hideMenu() {
    $menu.fadeOut(100);
    $menuIconClose.fadeOut(100);
    $menuIcon.fadeIn(100);
  }

  $menuIconClose.click(hideMenu);

  $(window).resize(function() {
    if ($(window).width() >= 840) {
      $menu.fadeIn(100);
      $menuIcon.fadeOut(100);
      $menuIconClose.fadeOut(100);
    }
    else {
      $menu.fadeOut(100);
      $menuIcon.fadeIn(100);
      $menuIconClose.fadeOut(100);
    }
  });
</script>

<!-- Stop page_header include -->


    <div class="container doc-container">
      
      

      
      <p> Looking for the <a href="/docs/0.14.0-incubating/">latest stable documentation</a>?</p>
      

      <div class="row">
        <div class="col-md-9 doc-content">
          <p>
            <a class="btn btn-default btn-xs visible-xs-inline-block visible-sm-inline-block" href="#toc">Table of Contents</a>
          </p>
          <h1 id="coordinator">Coordinator</h1>

<p>The Druid coordinator node is primarily responsible for segment management and distribution. More specifically, the Druid coordinator node communicates to historical nodes to load or drop segments based on configurations. The Druid coordinator is responsible for loading new segments, dropping outdated segments, managing segment replication, and balancing segment load.</p>

<p>The Druid coordinator runs periodically and the time between each run is a configurable parameter. Each time the Druid coordinator runs, it assesses the current state of the cluster before deciding on the appropriate actions to take. Similar to the broker and historical nodes, the Druid coordinator maintains a connection to a Zookeeper cluster for current cluster information. The coordinator also maintains a connection to a database containing information about available segments and rules. Available segments are stored in a segment table and list all segments that should be loaded in the cluster. Rules are stored in a rule table and indicate how segments should be handled.</p>

<p>Before any unassigned segments are serviced by historical nodes, the available historical nodes for each tier are first sorted in terms of capacity, with least capacity servers having the highest priority. Unassigned segments are always assigned to the nodes with least capacity to maintain a level of balance between nodes. The coordinator does not directly communicate with a historical node when assigning it a new segment; instead the coordinator creates some temporary information about the new segment under load queue path of the historical node. Once this request is seen, the historical node will load the segment and begin servicing it.</p>

<h2 id="quick-start">Quick Start</h2>

<p>Run:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>io.druid.cli.Main server coordinator
</code></pre></div>
<p>With the following JVM configuration:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>-server
-Xmx256m
-Duser.timezone=UTC
-Dfile.encoding=UTF-8

druid.host=localhost
druid.service=coordinator
druid.port=8082

druid.zk.service.host=localhost

druid.db.connector.connectURI=jdbc\:mysql\://localhost\:3306/druid
druid.db.connector.user=druid
druid.db.connector.password=diurd

druid.coordinator.startDelay=PT60s
</code></pre></div>
<h2 id="jvm-configuration">JVM Configuration</h2>

<p>The coordinator module uses several of the default modules in <a href="Configuration.html">Configuration</a> and has the following set of configurations as well:</p>

<table><thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead><tbody>
<tr>
<td><code>druid.coordinator.period</code></td>
<td>The run period for the coordinator. The coordinator’s operates by maintaining the current state of the world in memory and periodically looking at the set of segments available and segments being served to make decisions about whether any changes need to be made to the data topology. This property sets the delay between each of these runs.</td>
<td>PT60S</td>
</tr>
<tr>
<td><code>druid.coordinator.period.indexingPeriod</code></td>
<td>How often to send indexing tasks to the indexing service. Only applies if merge or conversion is turned on.</td>
<td>PT1800S (30 mins)</td>
</tr>
<tr>
<td><code>druid.coordinator.startDelay</code></td>
<td>The operation of the Coordinator works on the assumption that it has an up-to-date view of the state of the world when it runs, the current ZK interaction code, however, is written in a way that doesn’t allow the Coordinator to know for a fact that it’s done loading the current state of the world. This delay is a hack to give it enough time to believe that it has all the data.</td>
<td>PT300S</td>
</tr>
<tr>
<td><code>druid.coordinator.merge.on</code></td>
<td>Boolean flag for whether or not the coordinator should try and merge small segments into a more optimal segment size.</td>
<td>PT300S</td>
</tr>
<tr>
<td><code>druid.coordinator.conversion.on</code></td>
<td>Boolean flag for converting old segment indexing versions to the latest segment indexing version.</td>
<td>false</td>
</tr>
<tr>
<td><code>druid.coordinator.load.timeout</code></td>
<td>The timeout duration for when the coordinator assigns a segment to a historical node.</td>
<td>15 minutes</td>
</tr>
<tr>
<td><code>druid.manager.segment.pollDuration</code></td>
<td>The duration between polls the Coordinator does for updates to the set of active segments. Generally defines the amount of lag time it can take for the coordinator to notice new segments.</td>
<td>PT1M</td>
</tr>
<tr>
<td><code>druid.manager.rules.pollDuration</code></td>
<td>The duration between polls the Coordinator does for updates to the set of active rules. Generally defines the amount of lag time it can take for the coordinator to notice rules.</td>
<td>PT1M</td>
</tr>
<tr>
<td><code>druid.manager.rules.defaultTier</code></td>
<td>The default tier from which default rules will be loaded from.</td>
<td>_default</td>
</tr>
</tbody></table>

<h2 id="dynamic-configuration">Dynamic Configuration</h2>

<p>The coordinator has dynamic configuration to change certain behaviour on the fly. The coordinator a JSON spec object from the Druid <a href="MySQL.html">MySQL</a> config table. This object is detailed below:</p>

<p>It is recommended that you use the Coordinator Console to configure these parameters. However, if you need to do it via HTTP, the JSON object can be submitted to the overlord via a POST request at:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>http://&lt;COORDINATOR_IP&gt;:&lt;PORT&gt;/coordinator/config
</code></pre></div>
<p>A sample worker setup spec is shown below:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;millisToWaitBeforeDeleting&quot;</span><span class="p">:</span> <span class="mi">900000</span><span class="p">,</span>
  <span class="nt">&quot;mergeBytesLimit&quot;</span><span class="p">:</span> <span class="mi">100000000</span><span class="err">L</span><span class="p">,</span>
  <span class="nt">&quot;mergeSegmentsLimit&quot;</span> <span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
  <span class="nt">&quot;maxSegmentsToMove&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="nt">&quot;replicantLifetime&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
  <span class="nt">&quot;replicationThrottleLimit&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="nt">&quot;emitBalancingStats&quot;</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div>
<p>Issuing a GET request at the same URL will return the spec that is currently in place. A description of the config setup spec is shown below.</p>

<table><thead>
<tr>
<th>Property</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead><tbody>
<tr>
<td><code>millisToWaitBeforeDeleting</code></td>
<td>How long does the coordinator need to be active before it can start deleting segments.</td>
<td>90000 (15 mins)</td>
</tr>
<tr>
<td><code>mergeBytesLimit</code></td>
<td>The maximum number of bytes to merge (for segments).</td>
<td>100000000L</td>
</tr>
<tr>
<td><code>mergeSegmentsLimit</code></td>
<td>The maximum number of segments that can be in a single merge <a href="Tasks.html">task</a>.</td>
<td>Integer.MAX_VALUE</td>
</tr>
<tr>
<td><code>maxSegmentsToMove</code></td>
<td>The maximum number of segments that can be moved at any given time.</td>
<td>5</td>
</tr>
<tr>
<td><code>replicantLifetime</code></td>
<td>The maximum number of coordinator runs for a segment to be replicated before we start alerting.</td>
<td>15</td>
</tr>
<tr>
<td><code>replicationThrottleLimit</code></td>
<td>The maximum number of segments that can be replicated at one time.</td>
<td>10</td>
</tr>
<tr>
<td><code>emitBalancingStats</code></td>
<td>Boolean flag for whether or not we should emit balancing stats. This is an expensive operation.</td>
<td>false</td>
</tr>
</tbody></table>

<h3 id="running">Running</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>io.druid.cli.Main server coordinator
</code></pre></div>
<h2 id="rules">Rules</h2>

<p>Segments are loaded and dropped from the cluster based on a set of rules. Rules indicate how segments should be assigned to different historical node tiers and how many replicants of a segment should exist in each tier. Rules may also indicate when segments should be dropped entirely from the cluster. The coordinator loads a set of rules from the database. Rules may be specific to a certain datasource and/or a default set of rules can be configured. Rules are read in order and hence the ordering of rules is important. The coordinator will cycle through all available segments and match each segment with the first rule that applies. Each segment may only match a single rule</p>

<p>For more information on rules, see <a href="Rule-Configuration.html">Rule Configuration</a>.</p>

<h2 id="cleaning-up-segments">Cleaning Up Segments</h2>

<p>Each run, the Druid coordinator compares the list of available database segments in the database with the current segments in the cluster. Segments that are not in the database but are still being served in the cluster are flagged and appended to a removal list. Segments that are overshadowed (their versions are too old and their data has been replaced by newer segments) are also dropped.</p>

<h2 id="segment-availability">Segment Availability</h2>

<p>If a historical node restarts or becomes unavailable for any reason, the Druid coordinator will notice a node has gone missing and treat all segments served by that node as being dropped. Given a sufficient period of time, the segments may be reassigned to other historical nodes in the cluster. However, each segment that is dropped is not immediately forgotten. Instead, there is a transitional data structure that stores all dropped segments with an associated lifetime. The lifetime represents a period of time in which the coordinator will not reassign a dropped segment. Hence, if a historical node becomes unavailable and available again within a short period of time, the historical node will start up and serve segments from its cache without any those segments being reassigned across the cluster.</p>

<h2 id="balancing-segment-load">Balancing Segment Load</h2>

<p>To ensure an even distribution of segments across historical nodes in the cluster, the coordinator node will find the total size of all segments being served by every historical node each time the coordinator runs. For every historical node tier in the cluster, the coordinator node will determine the historical node with the highest utilization and the historical node with the lowest utilization. The percent difference in utilization between the two nodes is computed, and if the result exceeds a certain threshold, a number of segments will be moved from the highest utilized node to the lowest utilized node. There is a configurable limit on the number of segments that can be moved from one node to another each time the coordinator runs. Segments to be moved are selected at random and only moved if the resulting utilization calculation indicates the percentage difference between the highest and lowest servers has decreased.</p>

<h2 id="http-endpoints">HTTP Endpoints</h2>

<p>The coordinator node exposes several HTTP endpoints for interactions.</p>

<h3 id="get">GET</h3>

<ul>
<li><p><code>/info/coordinator</code></p>

<p>Returns the current true coordinator of the cluster as a JSON object.</p></li>
<li><p><code>/info/cluster</code></p>

<p>Returns JSON data about every node and segment in the cluster.  Information about each node and each segment on each node will be returned.</p></li>
<li><p><code>/info/servers</code></p>

<p>Returns information about servers in the cluster.  Set the <code>?full</code> query parameter to get full metadata about all servers and their segments in the cluster.</p></li>
<li><p><code>/info/servers/{serverName}</code></p>

<p>Returns full metadata about a specific server.</p></li>
<li><p><code>/info/servers/{serverName}/segments</code></p>

<p>Returns a list of all segments for a server.  Set the <code>?full</code> query parameter to get all segment metadata included</p></li>
<li><p><code>/info/servers/{serverName}/segments/{segmentId}</code></p>

<p>Returns full metadata for a specific segment.</p></li>
<li><p><code>/info/segments</code></p>

<p>Returns all segments in the cluster as a list.  Set the <code>?full</code> flag to get all metadata about segments in the cluster</p></li>
<li><p><code>/info/segments/{segmentId}</code></p>

<p>Returns full metadata for a specific segment</p></li>
<li><p><code>/info/datasources</code></p>

<p>Returns a list of datasources in the cluster.  Set the <code>?full</code> flag to get all metadata for every datasource in the cluster</p></li>
<li><p><code>/info/datasources/{dataSourceName}</code></p>

<p>Returns full metadata for a datasource</p></li>
<li><p><code>/info/datasources/{dataSourceName}/segments</code></p>

<p>Returns a list of all segments for a datasource.  Set the <code>?full</code> flag to get full segment metadata for a datasource</p></li>
<li><p><code>/info/datasources/{dataSourceName}/segments/{segmentId}</code></p>

<p>Returns full segment metadata for a specific segment</p></li>
<li><p><code>/info/rules</code></p>

<p>Returns all rules for all data sources in the cluster including the default datasource.</p></li>
<li><p><code>/info/rules/{dataSourceName}</code> </p>

<p>Returns all rules for a specified datasource</p></li>
</ul>

<h3 id="post">POST</h3>

<ul>
<li><p><code>/info/rules/{dataSourceName}</code></p>

<p>POST with a list of rules in JSON form to update rules.</p></li>
</ul>

<h2 id="the-coordinator-console">The Coordinator Console</h2>

<p>The Druid coordinator exposes a web GUI for displaying cluster information and rule configuration. After the coordinator starts, the console can be accessed at:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>http://&lt;COORDINATOR_IP&gt;:&lt;COORDINATOR_PORT&gt;
</code></pre></div>
<p>There exists a full cluster view, as well as views for individual historical nodes, datasources and segments themselves. Segment information can be displayed in raw JSON form or as part of a sortable and filterable table.</p>

<p>The coordinator console also exposes an interface to creating and editing rules. All valid datasources configured in the segment database, along with a default datasource, are available for configuration. Rules of different types can be added, deleted or edited.</p>

<h2 id="faq">FAQ</h2>

<ol>
<li><p><strong>Do clients ever contact the coordinator node?</strong></p>

<p>The coordinator is not involved in a query.</p>

<p>historical nodes never directly contact the coordinator node. The Druid coordinator tells the historical nodes to load/drop data via Zookeeper, but the historical nodes are completely unaware of the coordinator.</p>

<p>Brokers also never contact the coordinator. Brokers base their understanding of the data topology on metadata exposed by the historical nodes via ZK and are completely unaware of the coordinator.</p></li>
<li><p><strong>Does it matter if the coordinator node starts up before or after other processes?</strong></p>

<p>No. If the Druid coordinator is not started up, no new segments will be loaded in the cluster and outdated segments will not be dropped. However, the coordinator node can be started up at any time, and after a configurable delay, will start running coordinator tasks.</p>

<p>This also means that if you have a working cluster and all of your coordinators die, the cluster will continue to function, it just won’t experience any changes to its data topology.</p></li>
</ol>

        </div>
        <div class="col-md-3">
          <div class="searchbox">
            <gcse:searchbox-only></gcse:searchbox-only>
          </div>
          <div id="toc" class="nav toc hidden-print">
          </div>
        </div>
      </div>
    </div>

    <!-- Start page_footer include -->
<footer class="druid-footer">
<div class="container">
  <div class="text-center">
    <p>
    <a href="/technology">Technology</a>&ensp;·&ensp;
    <a href="/use-cases">Use Cases</a>&ensp;·&ensp;
    <a href="/druid-powered">Powered by Druid</a>&ensp;·&ensp;
    <a href="/docs/latest">Docs</a>&ensp;·&ensp;
    <a href="/community/">Community</a>&ensp;·&ensp;
    <a href="/downloads.html">Download</a>&ensp;·&ensp;
    <a href="/faq">FAQ</a>
    </p>
  </div>
  <div class="text-center">
    <a title="Join the user group" href="https://groups.google.com/forum/#!forum/druid-user" target="_blank"><span class="fa fa-comments"></span></a>&ensp;·&ensp;
    <a title="Follow Druid" href="https://twitter.com/druidio" target="_blank"><span class="fab fa-twitter"></span></a>&ensp;·&ensp;
    <a title="Download via Apache" href="https://www.apache.org/dyn/closer.cgi?path=/incubator/druid/0.14.0-incubating/apache-druid-0.14.0-incubating-bin.tar.gz" target="_blank"><span class="fas fa-feather"></span></a>&ensp;·&ensp;
    <a title="GitHub" href="https://github.com/apache/incubator-druid" target="_blank"><span class="fab fa-github"></span></a>
  </div>
  <div class="text-center license">
    Except where otherwise noted, licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>
  </div>
</div>
</footer>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40280432-1', 'auto');
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');

</script>
<script>
  function trackDownload(type, url) {
    ga('send', 'event', 'download', type, url);
  }
</script>
<script src="//code.jquery.com/jquery.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script src="/assets/js/druid.js"></script>
<!-- stop page_footer include -->


    <script>
    $(function() {
      $(".toc").load("/docs/0.6.33/toc.html");

      // There is no way to tell when .gsc-input will be async loaded into the page so just try to set a placeholder until it works
      var tries = 0;
      var timer = setInterval(function() {
        tries++;
        if (tries > 300) clearInterval(timer);
        var searchInput = $('input.gsc-input');
        if (searchInput.length) {
          searchInput.attr('placeholder', 'Search');
          clearInterval(timer);
        }
      }, 100);
    });
    </script>
  </body>
</html>
